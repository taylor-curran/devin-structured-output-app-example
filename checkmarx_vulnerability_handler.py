#!/usr/bin/env python3
import os
import time
import json
import requests
from typing import List, Dict, Any
from datetime import datetime
from dotenv import load_dotenv

load_dotenv()

api_key = os.getenv("DEVIN_API_KEY")
if not api_key:
    raise ValueError("DEVIN_API_KEY not found in .env file")

headers = {"Authorization": f"Bearer {api_key}"}


def mock_checkmarx_api() -> List[Dict[str, Any]]:
    """
    Mock the Checkmarx API to return a list of vulnerabilities.
    In production, this would make actual API calls to Checkmarx.
    """
    print("ğŸ” Checking Checkmarx API for vulnerabilities...")
    time.sleep(2)  # Simulate API delay
    
    # Mock vulnerability data with different repositories
    vulnerabilities = [
        {
            "id": "CX-SQL-001",
            "type": "SQL Injection",
            "severity": "High",
            "repository": "backend-api",
            "file": "/api/users.py",
            "line": 45,
            "description": "User input is not properly sanitized before being used in SQL query",
            "cwe": "CWE-89",
            "recommendation": "Use parameterized queries or prepared statements"
        },
        {
            "id": "CX-XSS-002",
            "type": "Cross-Site Scripting (XSS)",
            "severity": "Medium",
            "repository": "frontend-app",
            "file": "/frontend/components/UserProfile.tsx",
            "line": 78,
            "description": "User-controlled data is rendered without proper encoding",
            "cwe": "CWE-79",
            "recommendation": "Encode user input before rendering in HTML context"
        },
        {
            "id": "CX-PATH-003",
            "type": "Path Traversal",
            "severity": "High",
            "repository": "backend-api",
            "file": "/api/files.py",
            "line": 23,
            "description": "File path constructed from user input without validation",
            "cwe": "CWE-22",
            "recommendation": "Validate and sanitize file paths, use allowlist of permitted directories"
        },
        {
            "id": "CX-CRYPTO-004",
            "type": "Weak Cryptography",
            "severity": "Medium",
            "repository": "auth-service",
            "file": "/auth/password_utils.py",
            "line": 12,
            "description": "MD5 hash used for password storage",
            "cwe": "CWE-328",
            "recommendation": "Use bcrypt, scrypt, or Argon2 for password hashing"
        },
        {
            "id": "CX-HEADER-005",
            "type": "Missing Security Headers",
            "severity": "Low",
            "repository": "backend-api",
            "file": "/server/app.py",
            "line": 5,
            "description": "Response missing X-Frame-Options header",
            "cwe": "CWE-1021",
            "recommendation": "Add X-Frame-Options: DENY or SAMEORIGIN header"
        }
    ]
    
    print(f"âœ… Found {len(vulnerabilities)} vulnerabilities")
    return vulnerabilities


def create_orchestrator_session(vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Create the main orchestrator session that will manage the vulnerability remediation process"""
    
    # Group vulnerabilities by repository
    repos = {}
    for v in vulnerabilities:
        repo = v.get('repository', 'unknown')
        if repo not in repos:
            repos[repo] = []
        repos[repo].append(v)
    
    vulnerability_summary = ""
    for repo, vulns in repos.items():
        vulnerability_summary += f"\n**Repository: {repo}**\n"
        for v in vulns:
            vulnerability_summary += f"  - {v['id']}: {v['type']} ({v['severity']}) in {v['file']}:{v['line']}\n"
    
    prompt = f"""
    You are the orchestrator for vulnerability remediation across multiple repositories. The Checkmarx scan found the following vulnerabilities:
    {vulnerability_summary}
    
    Your tasks:
    1. Analyze the overall security posture across all repositories
    2. Prioritize vulnerabilities by severity and repository
    3. Create a remediation plan for each repository
    4. Monitor progress of individual vulnerability fixes
    
    Update this structured output as you work:
    {{
      "status": "initializing",
      "total_vulnerabilities": {len(vulnerabilities)},
      "high_severity": {len([v for v in vulnerabilities if v['severity'] == 'High'])},
      "medium_severity": {len([v for v in vulnerabilities if v['severity'] == 'Medium'])},
      "low_severity": {len([v for v in vulnerabilities if v['severity'] == 'Low'])},
      "remediation_plan": [],
      "sessions_created": 0,
      "sessions_completed": 0
    }}
    """
    
    print("ğŸš€ Creating orchestrator session...")
    response = requests.post(
        "https://api.devin.ai/v1/sessions",
        json={"prompt": prompt, "title": f"Vulnerability Orchestrator - {datetime.now().strftime('%Y-%m-%d %H:%M')}"},
        headers=headers
    )
    response.raise_for_status()
    return response.json()


def create_vulnerability_session(vulnerability: Dict[str, Any], orchestrator_session_id: str) -> Dict[str, Any]:
    """Create a Devin session for fixing a specific vulnerability"""
    
    repository = vulnerability.get('repository', 'unknown')
    
    prompt = f"""
    Fix the following security vulnerability detected by Checkmarx:
    
    **Repository**: {repository}
    **Vulnerability ID**: {vulnerability['id']}
    **Type**: {vulnerability['type']}
    **Severity**: {vulnerability['severity']}
    **File**: {vulnerability['file']}
    **Line**: {vulnerability['line']}
    **CWE**: {vulnerability['cwe']}
    
    **Description**: {vulnerability['description']}
    
    **Recommendation**: {vulnerability['recommendation']}
    
    Tasks:
    1. Analyze the vulnerable code
    2. Implement the recommended fix
    3. Test the fix to ensure it resolves the vulnerability
    4. Ensure no functionality is broken
    
    This is part of orchestrator session: {orchestrator_session_id}
    
    Update this structured output as you complete the fix:
    {{
      "repository": "{repository}",
      "vulnerability_id": "{vulnerability['id']}",
      "status": "analyzing",
      "fix_implemented": false,
      "tests_passed": false,
      "code_changes": [],
      "completion_time": null
    }}
    """
    
    response = requests.post(
        "https://api.devin.ai/v1/sessions",
        json={
            "prompt": prompt,
            "title": f"Fix {vulnerability['id']}: {vulnerability['type']}",
            "tags": ["vulnerability", vulnerability['severity'].lower(), vulnerability['cwe']]
        },
        headers=headers
    )
    response.raise_for_status()
    return response.json()


def wait_for_session_completion(session_id: str, timeout: int = 600) -> tuple[Dict[str, Any], str]:
    """Wait for a session to complete or reach a final state"""
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        try:
            response = requests.get(
                f"https://api.devin.ai/v1/sessions/{session_id}",
                headers=headers
            )
            response.raise_for_status()
            data = response.json()
            
            status = data.get("status", "unknown")
            if status in ["finished", "stopped", "error"]:
                return data.get("structured_output", {}), status
                
            print(".", end="", flush=True)
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 504:
                print("T", end="", flush=True)
            else:
                raise
        
        time.sleep(10)
    
    return {}, "timeout"


def main():
    """Main function to orchestrate vulnerability checking and remediation"""
    
    print("=" * 60)
    print("ğŸ” CHECKMARX VULNERABILITY REMEDIATION SYSTEM")
    print("=" * 60)
    
    # Step 1: Check Checkmarx API for vulnerabilities
    vulnerabilities = mock_checkmarx_api()
    
    if not vulnerabilities:
        print("âœ¨ No vulnerabilities found! Your code is secure.")
        return
    
    # Display vulnerability summary by repository
    print("\nğŸ“Š Vulnerability Summary:")
    high_count = len([v for v in vulnerabilities if v['severity'] == 'High'])
    medium_count = len([v for v in vulnerabilities if v['severity'] == 'Medium'])
    low_count = len([v for v in vulnerabilities if v['severity'] == 'Low'])
    
    print(f"  ğŸ”´ High: {high_count}")
    print(f"  ğŸŸ¡ Medium: {medium_count}")
    print(f"  ğŸŸ¢ Low: {low_count}")
    
    # Group by repository
    repos = {}
    for v in vulnerabilities:
        repo = v.get('repository', 'unknown')
        if repo not in repos:
            repos[repo] = []
        repos[repo].append(v)
    
    print("\nğŸ“¦ By Repository:")
    for repo, vulns in repos.items():
        print(f"  {repo}: {len(vulns)} vulnerabilities")
    
    # Step 2: Create orchestrator session
    print("\n" + "=" * 60)
    orchestrator = create_orchestrator_session(vulnerabilities)
    orchestrator_id = orchestrator["session_id"]
    print(f"âœ… Orchestrator session created:")
    print(f"   ID: {orchestrator_id}")
    print(f"   URL: {orchestrator['url']}")
    
    # Step 3: Create individual sessions for each vulnerability
    print("\n" + "=" * 60)
    print("ğŸ“ Creating vulnerability remediation sessions...")
    
    # Sort vulnerabilities by severity (High -> Medium -> Low)
    severity_order = {"High": 0, "Medium": 1, "Low": 2}
    sorted_vulnerabilities = sorted(vulnerabilities, key=lambda x: severity_order.get(x['severity'], 3))
    
    sessions = []
    for vuln in sorted_vulnerabilities:
        print(f"\nğŸ”§ Creating session for {vuln['id']} ({vuln['type']})...")
        try:
            session = create_vulnerability_session(vuln, orchestrator_id)
            sessions.append({
                "vulnerability": vuln,
                "session": session
            })
            print(f"   âœ… Session created: {session['url']}")
        except Exception as e:
            print(f"   âŒ Failed to create session: {e}")
    
    # Step 4: Display summary
    print("\n" + "=" * 60)
    print("ğŸ“‹ REMEDIATION SESSIONS CREATED")
    print("=" * 60)
    print(f"\nğŸ¯ Orchestrator Session:")
    print(f"   {orchestrator['url']}")
    print(f"\nğŸ”§ Vulnerability Fix Sessions ({len(sessions)} total):")
    
    for item in sessions:
        vuln = item['vulnerability']
        session = item['session']
        severity_icon = "ğŸ”´" if vuln['severity'] == 'High' else "ğŸŸ¡" if vuln['severity'] == 'Medium' else "ğŸŸ¢"
        repo = vuln.get('repository', 'unknown')
        print(f"   {severity_icon} [{vuln['id']}] {vuln['type']} - {repo}")
        print(f"      {session['url']}")
    
    # Optional: Wait for sessions to complete
    print("\n" + "=" * 60)
    wait_for_completion = input("Would you like to wait for sessions to complete? (y/n): ").strip().lower()
    
    if wait_for_completion == 'y':
        print("\nâ³ Monitoring session progress...")
        
        for item in sessions:
            vuln = item['vulnerability']
            session_id = item['session']['session_id']
            print(f"\nWaiting for {vuln['id']}", end="")
            
            output, status = wait_for_session_completion(session_id)
            
            if status == "finished":
                print(f" âœ… Completed!")
                if output:
                    print(f"   Output: {json.dumps(output, indent=2)}")
            elif status == "error":
                print(f" âŒ Error occurred")
            elif status == "timeout":
                print(f" â±ï¸  Timeout - session still running")
            else:
                print(f" âš ï¸  Status: {status}")
    
    print("\n" + "=" * 60)
    print("âœ¨ All sessions have been created. Monitor progress in the Devin dashboard.")
    print("=" * 60)


if __name__ == "__main__":
    main()
