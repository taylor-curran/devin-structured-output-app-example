#!/usr/bin/env python3
import os
import time
import json
import requests
from typing import List, Dict, Any
from datetime import datetime
from dotenv import load_dotenv

load_dotenv()

api_key = os.getenv("DEVIN_API_KEY")
if not api_key:
    raise ValueError("DEVIN_API_KEY not found in .env file")

headers = {"Authorization": f"Bearer {api_key}"}


def mock_checkmarx_api() -> List[Dict[str, Any]]:
    """
    Mock the Checkmarx API to return a list of vulnerabilities.
    In production, this would make actual API calls to Checkmarx.
    """
    print("ğŸ” Checking Checkmarx API for vulnerabilities...")
    time.sleep(2)  # Simulate API delay
    
    # Mock vulnerability data with different repositories
    vulnerabilities = [
        {
            "id": "CX-SQL-001",
            "type": "SQL Injection",
            "severity": "High",
            "repository": "backend-api",
            "file": "/api/users.py",
            "line": 45,
            "description": "User input is not properly sanitized before being used in SQL query",
            "cwe": "CWE-89",
            "recommendation": "Use parameterized queries or prepared statements"
        },
        {
            "id": "CX-XSS-002",
            "type": "Cross-Site Scripting (XSS)",
            "severity": "Medium",
            "repository": "frontend-app",
            "file": "/frontend/components/UserProfile.tsx",
            "line": 78,
            "description": "User-controlled data is rendered without proper encoding",
            "cwe": "CWE-79",
            "recommendation": "Encode user input before rendering in HTML context"
        },
        {
            "id": "CX-PATH-003",
            "type": "Path Traversal",
            "severity": "High",
            "repository": "backend-api",
            "file": "/api/files.py",
            "line": 23,
            "description": "File path constructed from user input without validation",
            "cwe": "CWE-22",
            "recommendation": "Validate and sanitize file paths, use allowlist of permitted directories"
        },
        {
            "id": "CX-CRYPTO-004",
            "type": "Weak Cryptography",
            "severity": "Medium",
            "repository": "auth-service",
            "file": "/auth/password_utils.py",
            "line": 12,
            "description": "MD5 hash used for password storage",
            "cwe": "CWE-328",
            "recommendation": "Use bcrypt, scrypt, or Argon2 for password hashing"
        },
        {
            "id": "CX-HEADER-005",
            "type": "Missing Security Headers",
            "severity": "Low",
            "repository": "backend-api",
            "file": "/server/app.py",
            "line": 5,
            "description": "Response missing X-Frame-Options header",
            "cwe": "CWE-1021",
            "recommendation": "Add X-Frame-Options: DENY or SAMEORIGIN header"
        }
    ]
    
    print(f"âœ… Found {len(vulnerabilities)} vulnerabilities")
    return vulnerabilities


def create_vulnerability_session(vulnerability: Dict[str, Any]) -> Dict[str, Any]:
    """Create a Devin session for fixing a specific vulnerability"""
    
    repository = vulnerability.get('repository', 'unknown')


    prompt = f"""
    Fix the following security vulnerability detected by Checkmarx:
    
    **Repository**: {repository}
    **Vulnerability ID**: {vulnerability['id']}
    **Type**: {vulnerability['type']}
    **Severity**: {vulnerability['severity']}
    **File**: {vulnerability['file']}
    **Line**: {vulnerability['line']}
    **CWE**: {vulnerability['cwe']}
    
    **Description**: {vulnerability['description']}
    
    **Recommendation**: {vulnerability['recommendation']}
    
    Tasks:
    1. Clone/access the {repository} repository
    2. Navigate to {vulnerability['file']}
    3. Analyze the vulnerable code at line {vulnerability['line']}
    4. Implement the recommended fix
    5. Test the fix to ensure it resolves the vulnerability
    6. Ensure no functionality is broken
    
    Update this structured output as you complete the fix:
    {{
      "repository": "{repository}",
      "vulnerability_id": "{vulnerability['id']}",
      "status": "analyzing",
      "fix_implemented": false,
      "tests_passed": false,
      "code_changes": [],
      "completion_time": null
    }}
    """
    
    response = requests.post(
        "https://api.devin.ai/v1/sessions",
        json={
            "prompt": prompt,
            "title": f"Fix {vulnerability['id']}: {vulnerability['type']}",
            "tags": ["vulnerability", vulnerability['severity'].lower(), vulnerability['cwe']]
        },
        headers=headers
    )
    response.raise_for_status()
    return response.json()




def wait_for_session_completion(session_id: str, timeout: int = 600) -> tuple[Dict[str, Any], str]:
    """Wait for a session to complete or reach a final state"""
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        try:
            response = requests.get(
                f"https://api.devin.ai/v1/sessions/{session_id}",
                headers=headers
            )
            response.raise_for_status()
            data = response.json()
            
            status = data.get("status", "unknown")
            if status in ["finished", "stopped", "error"]:
                return data.get("structured_output", {}), status
                
            print(".", end="", flush=True)
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 504:
                print("T", end="", flush=True)
            else:
                raise
        
        time.sleep(10)
    
    return {}, "timeout"


def main():
    """Main function to orchestrate vulnerability checking and remediation"""
    
    print("=" * 60)
    print("ğŸ” CHECKMARX VULNERABILITY REMEDIATION SYSTEM")
    print("=" * 60)
    
    # Step 1: Check Checkmarx API for vulnerabilities
    vulnerabilities = mock_checkmarx_api()
    
    if not vulnerabilities:
        print("âœ¨ No vulnerabilities found! Your code is secure.")
        return
    
    # Display vulnerability summary by repository
    print("\nğŸ“Š Vulnerability Summary:")
    high_count = len([v for v in vulnerabilities if v['severity'] == 'High'])
    medium_count = len([v for v in vulnerabilities if v['severity'] == 'Medium'])
    low_count = len([v for v in vulnerabilities if v['severity'] == 'Low'])
    
    print(f"  ğŸ”´ High: {high_count}")
    print(f"  ğŸŸ¡ Medium: {medium_count}")
    print(f"  ğŸŸ¢ Low: {low_count}")
    
    # Group by repository
    repos = {}
    for v in vulnerabilities:
        repo = v.get('repository', 'unknown')
        if repo not in repos:
            repos[repo] = []
        repos[repo].append(v)
    
    print("\nğŸ“¦ By Repository:")
    for repo, vulns in repos.items():
        print(f"  {repo}: {len(vulns)} vulnerabilities")
    
    # Step 2: Create individual sessions for each vulnerability
    print("\n" + "=" * 60)
    print("ğŸ“ Creating vulnerability remediation sessions...")
    
    # Sort vulnerabilities by severity (High -> Medium -> Low)
    severity_order = {"High": 0, "Medium": 1, "Low": 2}
    sorted_vulnerabilities = sorted(vulnerabilities, key=lambda x: severity_order.get(x['severity'], 3))
    
    sessions = []
    for vuln in sorted_vulnerabilities:
        print(f"\nğŸ”§ Creating session for {vuln['id']} ({vuln['type']})...")
        try:
            session = create_vulnerability_session(vuln)
            sessions.append({
                "vulnerability": vuln,
                "session": session
            })
            print(f"   âœ… Session created: {session['url']}")
        except Exception as e:
            print(f"   âŒ Failed to create session: {e}")
    
    # Step 3: Display summary
    print("\n" + "=" * 60)
    print("ğŸ“ REMEDIATION SESSIONS CREATED")
    print("=" * 60)
    print(f"\nğŸ”§ Vulnerability Fix Sessions ({len(sessions)} total):")   
    for item in sessions:
        vuln = item['vulnerability']
        session = item['session']
        severity_icon = "ğŸ”´" if vuln['severity'] == 'High' else "ğŸŸ¡" if vuln['severity'] == 'Medium' else "ğŸŸ¢"
        repo = vuln.get('repository', 'unknown')
        print(f"   {severity_icon} [{vuln['id']}] {vuln['type']} - {repo}")
        print(f"      {session['url']}")
    
    # Optional: Wait for sessions to complete
    print("\n" + "=" * 60)
    wait_for_completion = input("Would you like to wait for sessions to complete? (y/n): ").strip().lower()
    
    if wait_for_completion == 'y':
        print("\nâ³ Monitoring session progress...")
        
        for item in sessions:
            vuln = item['vulnerability']
            session_id = item['session']['session_id']
            print(f"\nWaiting for {vuln['id']}", end="")
            
            output, status = wait_for_session_completion(session_id)
            
            if status == "finished":
                print(f" âœ… Completed!")
                if output:
                    print(f"   Output: {json.dumps(output, indent=2)}")
            elif status == "error":
                print(f" âŒ Error occurred")
            elif status == "timeout":
                print(f" â±ï¸  Timeout - session still running")
            else:
                print(f" âš ï¸  Status: {status}")
    
    print("\n" + "=" * 60)
    print("âœ¨ All sessions have been created. Monitor progress in the Devin dashboard.")
    print("=" * 60)


if __name__ == "__main__":
    main()
